\subsection{Генерация вспомогательных конструкций}

Для успешной работы программ, генерируемых метакомпилятором, необходимо не только конвертировать существующие языковые конструкции процедурно-параметрической парадигмы, но и ещё добавлять дополнительные функции и глобальные переменные, для хранения служебных данных о параметризованных типах и функциях.
Поскольку метакомпилятор обязан поддерживать независимую компиляцию нескольких модулей параллельно, для всех таких конструкций используется атрибут ``weak'', являющийся распространённым расширением языка С, которое поддерживается в компиляторе GCC.

Чтобы поведение результирующей программы не зависело от порядка её компиляции, были использованы конструкторы, которые тоже являются функционалом, впервые добавленным в компилятор GCC.
Они определяются атрибутом ``constructor'', который принимает на вход приоритет --- целое число больше 100.
Разрабатываемый метакомпилятор используется приоритеты 101, 102 и 103.

\subsubsection{Конструкторы обобщённых структур}

Каждой конкретной специализации обобщённой структуры необходимо назначить уникальное числовое значение --- идентификатор типа и значение тэга.
В целях экономии памяти, затрачиваемой на хранения таблиц эти значения должны начинаться с нуля и идти по порядку.
Присвоения этих значений происходит в момент запуска получаемой программы в произвольном порядке, используя конструкторы с приоритетом 101.

Такой конструктор отдельно определяется для каждой специализации, на листинге \ref{lst:constructorsstruct} приведены примеры двух конструкторов для обобщённой структуры Figure, вместе с нужными для их работы глобальными переменными.
На момент запуска процесса, в программе не может быть больше одного потока, поэтому данный код не вызывает проблем с многопоточностью, не смотря на использование глобальных переменных.

\begin{lstlisting}[language=c, caption={Конструкторы обобщённой структуры}, label={lst:constructorsstruct}]
  int __attribute__((weak)) Figure_Rectangle_tag_value;
  int __attribute__((weak)) Figure_Box_tag_value;
  int __attribute__((weak)) Figure_tag_count = 0;

  void __attribute__((weak, constructor(101))) Figure_Box_constructor() {
    Figure_Box_tag_value = Figure_tag_count++;
  }

  void __attribute__((weak, constructor(101))) Figure_Rectangle_constructor() {
    Figure_Rectangle_tag_value = Figure_tag_count++;
  }
\end{lstlisting}

\subsubsection{Конструкторы таблиц параметрических функций}

Для обеспечения динамического полиморфизма параметрических функций используются таблицы указателей, размер которых не известен на этапе компиляции, так как он совпадает с количеством доступных специализаций использованных обобщённых структур.
Поэтому память под дин необходимо выделять уже после запуска программы.
За это отвечают конструкторы с приоритетом 102, поскольку для данного процесса необходимо знать точное количество специализаций, которая храниться в переменных формата ``\texttt{*_tag_count}''.
Для выделения динамической памяти они используют библиотечную функцию ``\texttt{calloc}'', которая может быть недоступна на некоторых встроенных системах, таких как например WebAssembly.

Также необходимо определить тип указателя на функции, и глобальную переменную для хранения таблицы (см. листинг \ref{lst:constructorfunc}).
Данный процесс немного отличается для мультиметодов, так как для них необходимо вычислять размер таблицы.

\begin{lstlisting}[language=c, caption={Конструктор параметрической функции}, label={lst:constructorfunc}]
  typedef void(*Draw_pointer)(Figure* d);
  Draw_pointer* Draw_table = NULL;

  void __attribute__((weak, constructor(102))) Draw_constructor() {
    Draw_table = calloc(Figure_tag_count, sizeof(void*));
  }
\end{lstlisting}

\subsubsection{Конструкторы реализаций параметрических функций}

Указатель на каждую реализацию параметрической функции должен быть записан в таблицу указателей, и данная операция не может быть произведена до того как стало известно какие значения идентификаторов типов были назначены, и до того как была выделана динамическая память под эту таблицу.
Для каждой такой реализации создаётся конструктор с приоритетом 103, и использует формулу для вычисления нужной позиции в таблице указателей (см. листинг \ref{lst:constructorfuncimpl}).
Эта формула совпадает с той, которая будет использована для выбора указателя на нужную реализацию при вызове параметрической функции.
Определение дополнительных глобальных переменных в данном случае не требуется.

\begin{lstlisting}[language=c, caption={Конструктор реализации параметрической функции}, label={lst:constructorfuncimpl}]
  void __attribute__((weak, constructor(103))) Draw_Figure_Box_constructor() {
    Draw_table[Figure_Box_tag_value] = &Draw_Figure_Box;
  }
\end{lstlisting}

В случаях когда такой конструктор отсутствует, так как программист забыл определить реализацию для данной специализации, значение указателя будет либо нулевым, что приведёт к ошибке при попытке вызова, либо он будет указывать на реализацию по умолчанию, которую можно было указать при определение заголовка параметрической функции (см. листинг \ref{lst:exampledefault}).

\begin{lstlisting}[language=c, caption={Пример реализации по умолчанию}, label={lst:exampledefault}]
  bool Intersect<Figure* f1, Figure* f2>() = 0;

  bool Intersect<Figure* f1, Figure* f2>() {
    if(f1->tag > f2->tag) {
      return Intersect<f2, f1>();
    }
    return false;
  }
\end{lstlisting}

\subsection{Выбор средств реализации}
Язык программирования был выбран С, поскольку это тот язык, над которым будет работать метакомпилятор.

В качестве среды разработки выбрана Visual Studio Code, поскольку она имеет встроенные функции интеграции множеством различных языков программирования.

Git выбран в качестве системы контроля версий из-за ее удобства, надежности и гибкости, а GitHub выбран в качестве веб-сервиса для демонстрации взаимодействия с Git.

В качестве сборочной системы был выбран Makefile, в связи с его простотой и совместимостью с языком программирования С.

\subsection{Тестирование программы}

Для разработки метакомпилятора использовалось регрессионное и ручное тестирование.
Было предоставлено некоторое количество входных файлов, содержащих пограничные случаи синтаксиса языка C,
и набор функций метакомпилятора, которые преобразуют исходный код каким-то предопределённым способом, например извлекают список всех функций.
Каждая такая функция считывала содержимая входного файла и записывала результат в поток стандартного вывода (см. листинг \ref{lst:testexample}).

\begin{lstlisting}[language=c, caption={Пример тестирующей функции для парсера}, label={lst:testexample}]
  void testfunc_named_types(const char* input_file) {
    Emitter em = {.file = stdout};
    Parser parser = {0};
    parser_read_file(&parser, input_file);
    parser_emit_typedefs(&parser, &em, true);

    parser_delete(&parser);
  }
\end{lstlisting}

После внесения изменений в метакомпилятор, эти функции запускались для всех нужных входных файлов, и их выводы сравнивались с предыдущей версией.
Таким образом выявлялись ошибки, возникшии в последствии добавления нового функционала метакомпилятора.

\subsection{Пути дальнейшего развития}
Возможны несколько путей дальнейшего развития разработанного компилятора:
\begin{enumerate}
  \item \textbf{Расширение поддержки языковых конструкций}:
  Можно добавить поддержку других более специфических языковых конструкций, таких как специализации по нетиповому признаку и рекурсивно вложенные типы, которые также являются частью процедурно-параметрической парадигмы программирования~\cite{легалов2023расширение}.
  Это позволит расширить возможности языка и улучшить его удобство использования.

  \item \textbf{Оптимизация производительности метакомпилятора}:
  Можно провести оптимизации компилятора, чтобы улучшить его производительность. Это также уменьшит временные затраты на его тестирование.

  \item \textbf{Разработка инструментов поддержки разработчиков}:
  Можно создать дополнительные инструменты, которые помогут разработчикам при использовании полученного компилятора.
  Такие как, например, файл ``\texttt{.sublime-syntax}'' для поддержки синтаксической подсветки в текстовом редакторе Sublime Text~\cite{sublimetextSyntaxDefinitions}, или расширение для среды разработки Visual Studio Code.

  \item \textbf{Добавление других целевых платформ}:
  Можем расширить поддержку различных целевых платформ, таких как другие архитектуры процессоров или операционные системы, так как в настоящие время метакомпилятор работает только на системе Linux+GCC и получаемый код имеет зависимость на стандартную библиотеку ``\texttt{libc}''.
\end{enumerate}

% todo
% Эксперименты с другими синтаксическими концепциями и стилями
% Поддержание других платформ, кроме Linux+GCC
% Альтернативные подходы, например интеграция в LLVM
% Больше параметрических конструкций

\subsection*{Выводы по главе}
\addcontentsline{toc}{subsection}{Выводы по главе}
В данной главе рассмотрены средства реализации метакомпилятора и особенности реализации.
Также рассмотрено использование конструкторов в языке программирования С, примеры регрессионного тестирования.
