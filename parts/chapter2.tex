\subsection{Описание предлагаемого расширения}

% todo[feedback]
% Наверно перед всем этим техническим описанием необходимо дать
% описание предлагаемого расширения. Можно непосредственно по
% статьям. Ведь иначе непонятно, о чем идет речь. Нет ни синтаксиса, ни
% семантики. Желательно также привести примеры программ,
% демонстрирующие специфику использования.

\subsubsection{Процедурно-параметрическая парадигма}

Процедурно-параметрическая парадигма программирования представляет собой подход, который предлагается для инструментальной поддержки эволюционно расширяемого множественного полиморфизма. Она решает проблему выбора реализации мультиметодов, то есть методов, чей выбор зависит не только от первого аргумента, но также от других аргументов.

Использование параметрической зависимости между аргументами в процедурно-параметрической парадигме позволяет избежать анализа вариантов в иерархической форме и обеспечивает независимость одного аргумента от другого, то есть процедур от данных. Этот подход является основой для реализации параметрического полиморфизма и процедурно-параметрической парадигмы программирования.

Одно из отличий процедурно-параметрической парадигмы от объектно-ориен\-тированного и процедурного программирования заключается в порядке выбора альтернатив. В процедурном программировании сначала определяется функция, а затем внутри нее выбирается реализация для нужного типа. В объектно-ориентированном программировании, наоборот, сначала загружается виртуальная таблица методов для нужного типа, а затем выбирается конкретный метод.
В процедурно-параметрической парадигме данный выбор происходит одновременно~\cite{легалов2000процедурно}.

Один из простых способов параметризации заключается в использовании многомерных массивов, в которых каждая из размерностей определяет один из варьируемых параметров. Значения элементов такого массива представляют выбираемые альтернативы. В данном случае, для рассматриваемого примера, будет строиться двухмерный массив, где каждое измерение соответствует одному из варьируемых параметров (см. Таб. \ref{table:parametric}).

\begin{table}[h!]
  \centering
  \begin{tabular}{|l|l|l|l|l|}
    \hline
    Значения & \multicolumn{4}{c|}{Значения типа}                                       \\\cline{2-5}
    функции  & $t_1$                              & $t_2$       & $\dots$ & $t_n$       \\\hline
    $f_1$    & $\phi_{11}$                        & $\phi_{12}$ & $\dots$ & $\phi_{1n}$ \\\hline
    $f_2$    & $\phi_{21}$                        & $\phi_{22}$ & $\dots$ & $\phi_{2n}$ \\\hline
    $\dots$  & $\dots$                            & $\dots$     & $\dots$ & $\dots$     \\\hline
    $f_m$    & $\phi_{m1}$                        & $\phi_{m2}$ & $\dots$ & $\phi_{mn}$ \\\hline
  \end{tabular}
  \caption{Пример параметрической зависимости.}
  \label{table:parametric}
\end{table}

% плагиат:
Для табличного доступа не имеет значения, в какой последовательности определяются и используются индексы элемента. Программная реализация выбора альтернатив с применением параметров позволяет получить еще один подход, который можно назвать процедурно-параметрическим программированием.

\subsubsection{Конструирование программных объектов}

ППП предлагает ряд специфических способов создания программных объектов, которые отсутствуют в процедурном и объектно-ориентированном подходе.
Перед тем как перейти к описанию программ на процедурно-параметрическом языке, рассмотрим основные понятия, которые используются при написании ПП программ.

\begin{enumerate}
  \item \textbf{Параметрические обобщения} \\
    Для создания \textbf{обобщенных структур} данных, в процедурно-параметрическом программировании используются новые программные объекты, называемые параметрическими обобщениями.
    % todo
    Этот программный объект не имеет аналогов в процедурном и объектно-ориентированном программировании, но решает задачи, аналогичные задачам вариантов объединений в процедурном программировании и базовых классов в объектно-ориентированном программировании.
    % ППП предоставляет возможность создания \textbf{обобщенных структур} данных, которые могут работать с разными типами данных.

  \begin{centerframebox}
    \small
    \begin{grammar}
      <ОбобщеннаяСтруктура> ::= <Структура> `<' <СписокСпециализаций> `>'

      <СписокСпециализаций> ::= (<ИмяТипа> `;')*
    \end{grammar}
  \end{centerframebox}

\begin{lstlisting}[language=c, caption={Пример параметрического обобщения}, label={lst:fancystruct}]
  typedef struct Root {} <
    struct OneRoot;
    struct TwoRoots;
    struct NoRoot;
  > Root;
\end{lstlisting}

  \item \textbf{Обобщающие параметрическии функции} \\
    Обобщающие \textbf{параметрическии функции} в процедурно-параметрическом программировании, также известные как параметрические методы, предоставляют механизм параметрического полиморфизма, который не имеет аналогов в других парадигмах программирования.
    Основная задача параметрических процедур заключается в описании параметрических аргументов и обработчика по умолчанию.
    Функционал для отдельных специализированных типов они не определяют.
    Подобные, но не идентичные свойства можно наблюдать у методов базовых классов в объектно-ориентированном программировании.

  \begin{centerframebox}
    \small
    \begin{grammar}
      <ПараметрическаяФункция> ::= <ТипВозврата> <ИмяФункции> \\
      `<' <СписокПараметрическихАргументов> `>' `(' <СписокАргументов> `)' \\
      (<ТелоФункции> | `=' `0')

      <СписокПараметрическихАргументов> ::= <Аргумент> (`,' <Аргумент>)*

      <Аргумент> ::= <ОбобщённыйТип> `*' <ИмяАргумента>
    \end{grammar}
  \end{centerframebox}

\begin{lstlisting}[language=c, caption={Пример параметрической функции}, label={lst:fancyheader}]
  void Print<Root* root>() = 0;
\end{lstlisting}

  \item \textbf{Специализированные параметрические обработчики} \\
    В ППП можно определять специализированные обработчики, которые предоставляют различное поведение в зависимости от типов данных, с которыми они работают.
    Такие процедуры, расширяют функционал существующей обобщающей параметрической функции.
    Они непосредственно задают поведение для каждой из специализаций, и являются \textbf{реализациями параметрических функций}.

  \begin{centerframebox}
    \small
    \begin{grammar}
      <СпециализированнаяФункция> ::= <ТипВозврата> <ИмяФункции> \\
      `<' <СписокСпецПараметров> `>' `(' <СписокПараметров> `)'
      <ТелоФункции>

      <СписокСпецПараметров> ::= <СпецАргумент> (`,' <СпецАргумент>)*

      <СпецАргумент> ::= <ОбобщённыйТип> `<' <ИмяТипа> `>' `*' <ИмяАргумента>
    \end{grammar}
  \end{centerframebox}

\begin{lstlisting}[language=c, caption={Пример специализированного обработчика}, label={lst:fancymethod}]
  void Print<Root<OneRoot>* root>() {
    printf("x = %.2f\n", root->!x);
  }
\end{lstlisting}
\end{enumerate}

% todo:
% 4. FANCY_STRUCTS Обобщения данных строятся с использованием новых программных
% объектов, названных параметрическими обобщениями. Они предназначены для группировки параметров, обеспечивающих однозначную
% связь с соответствующими специализированными структурами. Данный
% программный объект не имеет аналогов в процедурном и ОО программировании. Он решает задачи, схожие с задачами вариантов в процедурных языках и базовых классов в ОО языках.
% 5. FANCY_HEADER Обобщающие параметрические процедуры (или просто параметрические процедуры) поддерживают механизм параметрического полиморфизма. Они не имеют аналогов в других парадигмах программирования. Их основная задача - описание параметрических аргументов,
% обработчика по умолчанию. Похожие, но не совпадающие свойства,
% можно наблюдать у методов базовых классов.
% 6. FANCY_METHOD Специализированные параметрические обработчики (или просто
% параметрические обработчики) - процедуры, расширяющие функциональность обобщающей параметрической процедуры. Они непосредственно задают функциональность для каждой из специализаций.

\subsubsection{Пример программы}

Приведенный ниже код, основанный на предыдущей статье~\cite{легалов2000процедурно}, демонстрирует реализацию алгоритма для нахождения действительных корней квадратного уравнения с использованием процедурно-параметрической парадигмы (см. листинг \ref{lst:exampleroots}).
Этот код является адаптированной версией предыдущей работы, внедряющей новые идеи и концепции.

\begin{lstlisting}[language=c, caption={Пример программы, которая находит корни квадратного уравнения}, label={lst:exampleroots}]
  #include <stdio.h>
  #include <math.h>

  typedef struct OneRoot {
    double x;
  } OneRoot;

  typedef struct TwoRoots {
    double x1;
    double x2;
  } TwoRoots;

  typedef struct NoRoot {
    char* msg;
  } NoRoot;

  typedef struct Root {} <
    struct OneRoot;
    struct TwoRoots;
    struct NoRoot;
  > Root;

  void Print<Root* root>() = 0;

  void Print<Root<OneRoot>* root>() {
    printf("x = %.2f\n", root->!x);
  }

  void Print<Root<TwoRoots>* root>() {
    printf("x1 = %.2f\n", root->!x1);
    printf("x2 = %.2f\n", root->!x2);
  }

  void Print<Root<NoRoot>* root>() {
    printf("error: %s\n", root->!msg);
  }

  void EvalOneRoot(double a, double b, Root* root) {
    Root<OneRoot> res;
    res!x = (-b) / (2 * a);
    Root* resptr = &res;
    *root = *resptr;
  }

  void EvalTwoRoots(double a, double b, double d, Root* root) {
    Root<TwoRoots> res;
    res!x1 = (-b - d) / (2 * a);
    res!x2 = (-b + d) / (2 * a);
    Root* resptr = &res;
    *root = *resptr;
  }

  void EvalNoRoot(Root* root) {
    Root<NoRoot> res;
    res!msg = "No roots found!";
    Root* resptr = &res;
    *root = *resptr;
  }

  void SolveQuadratic(double a, double b, double c, Root* root) {
    double d = b*b - 4*a*c;
    if(d == 0) {
      EvalOneRoot(a, b, root);
    } else if(d > 0) {
      EvalTwoRoots(a, b, d, root);
    } else {
      EvalNoRoot(root);
    }
  }

  int main() {
    double a,b,c;
    Root root;
    printf("Input a, b, and c:\n");
    scanf("%lf%lf%lf", &a, &b, &c);
    SolveQuadratic(a, b, c, &root);
    Print<&root>();
    return 0;
  }
\end{lstlisting}

\subsection{Архитектура программы}

Архитектура компилятора обычно разделяется на три основных компонента: лексический анализатор (лексер), синтаксический анализатор (парсер) и генератор выходного кода (см. Рис. \ref{fig:architecture}).

\begin{enumerate}
  \item Лексер читает исходный код и разбивает его на лексемы, такие как идентификаторы, числа, строки и операторы. Каждая лексема имеет свой тип и значение, которые затем передаются парсеру.

  \item Парсер анализирует последовательность лексем и строит из них абстрактное синтаксическое дерево (AST), который представляет структуру программы. В AST каждая лексема становится узлом, а операторы и выражения представляются в виде вложенных узлов. AST является внутренним представлением программы, которое затем может быть использовано для генерации кода.

  \item Генератор выходного кода принимает AST и генерирует код на целевом языке программирования, например, на машинном языке или на языке C. Генератор может проходить по AST рекурсивно и генерировать соответствующий код для каждого узла AST.
\end{enumerate}

Таким образом, компилятор разделяет процесс компиляции на несколько этапов: лексический анализ, синтаксический анализ и генерацию кода. Это позволяет компилятору разделять сложную задачу компиляции на более простые этапы и упрощать процесс реализации.

Однако в разрабатываемом метакомпиляторе нет необходимости строить полное AST, так как большинство конструкций стандартного языка C может быть обработано без изменений.
Он будет строить упрощенное дерево разбора, которое будет включать только те элементы, которые требуются для расширения языка.
Это позволит ускорить процесс компиляции и сократить потребление памяти.
Построение упрощенного дерева разбора также позволит компилятору легко производить операции поиска и замены элементов, что упростит реализацию расширенных возможностей языка.

\begin{figure}[th!]
  \centering
  \begin{tikzpicture}[node distance=1cm]
    \tikzstyle{process} = [rectangle, minimum width=2cm, minimum height=1cm, text centered, draw=black, fill=orange!30]
    \tikzstyle{arrow} = [thick,->,>=stealth]
    \tikzstyle{database} = [trapezium, trapezium left angle=70, trapezium right angle=110, minimum width=2cm, minimum height=1cm, text centered, draw=black, fill=blue!30]
    \tikzstyle{binary} = [diamond, text centered, draw=black, fill=white!30, aspect=2]

    \node (cpp) [database] {GCC Preprocessor};
    \node (source) [binary, right=of cpp] {Source Code};
    \node (lexer) [process, below=of cpp] {Lexer};
    \node (parser) [process, right=of lexer] {Parser};
    \node (code) [process, right=of parser] {Code Generator};
    \node (cc) [database, below=of code] {GCC Compiler};
    \node (binary) [binary, left=of cc] {Binary};

    \draw [arrow] (source) -- (cpp);
    \draw [arrow] (cpp) -- (lexer);
    \draw [arrow] (lexer) -- (parser) node[fill=white,midway,rotate=90] {tokens};
    \draw [arrow] (parser) -- (code) node[fill=white,midway,rotate=90] {AST};
    \draw [arrow] (code) -- (cc);
    \draw [arrow] (cc) -- (binary);

  \end{tikzpicture}
  \caption{Базовая архитектура метакомпилятора}
  \label{fig:architecture}
\end{figure}

\subsubsection{Архитектура лексического анализатора}

Лексический анализатор является первым шагом в компиляции и отвечает за разбор исходного кода на отдельные токены.
Он работает по принципу пошагового чтения исходного файла, считывая по одному байту за раз и запоминая следующий ``взгляд'' на байт (peeked byte), чтобы решить, какой символ в следующей позиции в коде и когда должна заканчиваться последовательность символов текущего токена (см. листинг \ref{lst:lexerstruct}).
Это позволяет лексическому анализатору работать с любыми источниками данных, такими как строки, каналы межпроцессорной коммуникации и реальные файлы на диске, без необходимости загрузки всего файла в память.

\begin{lstlisting}[language=c, caption={Упрощённая структура лексера}, label={lst:lexerstruct}]
  typedef struct Lexer {
    File* file;
    char peeked_char;

    Loc current_location;
    Token peeked_token;
  } Lexer;
\end{lstlisting}

Поскольку лексический анализатор обрабатывает исходный код по одному символу за раз, то он может легко запоминать позицию каждого токена, который он обрабатывает. Эта информация о позиции токена (обычно имя файла и номер строки) используется в дальнейшем для формирования сообщений об ошибках, которые помогают разработчику быстро понять, где именно в коде находится проблема (см. листинг \ref{lst:tokenstruct}).

\begin{lstlisting}[language=c, caption={Cтруктура токена и его позиции}, label={lst:tokenstruct}]
  typedef struct Loc {
    const char* filename;
    int line_num;
    int col_num;
    int byte_num;
  } Loc;

  typedef struct Token {
    char* data;
    size_t length;
    size_t capacity;
    TokenKind kind;
    Loc location;
  } Token;
\end{lstlisting}

Интерфейсы лексический анализатора предоставляют собой набор функций для работы с символами и токенами в потоке данных.
Функция ``\texttt{lexer_next_char}'' запрашивает у файла следующий символ, ``\texttt{lexer_peek_char}'' возвращает следующий символ без изменения текущей позиции, и ``\texttt{lexer_drop_char}'' пропускает текущий символ, который был прочитан функцией ``\texttt{lexer_peek_char}'', и перемещает позицию лексера на следующий символ (см. листинг \ref{lst:lexertofile}).
Подразумевается что функция ``\texttt{lexer_next_char}'' не должна быть использована напрямую.

\begin{lstlisting}[language=c, caption={Интерфейс между лексером и файлом}, label={lst:lexertofile}]
  char lexer_next_char(Lexer* l);
  char lexer_peek_char(Lexer* l);
  char lexer_drop_char(Lexer* l);
\end{lstlisting}

Также имеется аналогичный интерфейс для взаимодействия с самим лексером.
Он выстроен по такому-же принципу с функциями ``\texttt{next}'', ``\texttt{peek}'' и ``\texttt{drop}'', но на этот раз не для символов, а для токенов (см. листинг \ref{lst:parsertolexer}).
Самое важное тут то, что функция ``\texttt{lexer_next_token}'' отвечает за сбор токена из символов.
Она запрашивает символы из файла по одному, и собирает из них следующий токен, параллельно определяя его тип.
Далее подобная система будет использовать в синтаксическом анализаторе, только он будет собирать синтаксические деревья из токенов, а не токены из символов.

\begin{lstlisting}[language=c, caption={Интерфейс между парсером и лексером}, label={lst:parsertolexer}]
  Token lexer_next_token(Lexer* l);
  Token lexer_peek_token(Lexer* l);
  Token lexer_drop_token(Lexer* l);
\end{lstlisting}

\subsubsection{Архитектура синтаксического анализатора}

Основная задача парсера --- преобразование исходного кода в AST (абстрактное синтаксическое дерево), в котором каждый узел представляет собой элемент языка программирования (например, описание типа, объявление переменной или вызов функции). В ходе работы парсер использует лексер для чтения исходного кода, и сохраняет наеденные типы в таблицы имён.
Отдельно хранятся именные типы в хеш-таблице ``\texttt{typedefs}'', структуры в хеш-таблице ``\texttt{structs}'' и параметрические функция
в хеш-таблице ``\texttt{polymorphic_functions}'' (см. листинг \ref{lst:parserstruct}).

\begin{lstlisting}[language=c, caption={Упрощённая структура парсера}, label={lst:parserstruct}]
  typedef struct Parser {
    Lexer lexer;

    NamedType* typedefs;
    NamedType* structs;
    NamedFunction* polymorphic_functions;
  } Parser;
\end{lstlisting}

Синтаксический анализ выполняется отдельно для каждого выражения на верхнем уровне файла.
Функция ``\texttt{parser_parse_line}'' считывает токены из лексера до конца текущего выражения, и оставляет его курсор ровно в начале следующего выражения.
Таким образом, вызывая эту функцию в цикле, можно обработать все выражения в файле.
Также эта функция сохраняет найденные ей определения типов в таблицу имён ``\texttt{typedefs}'', поскольку для успешного синтаксического анализа языка программирования C необходимо различать какие идентификаторы являются именами типов, а какие всего лишь названиями переменных.

Для упрощения процесса синтаксического анализа были введены две вспомогательные функции, построенные поверх интерфейса с лексическим анализатором (см. листинг \ref{lst:parserutils}).
Функция ``\texttt{parser_peek_token}'' запрашивает текущий токен у лексера, и выбрасывает токены нерелевантных типов, таких как например комментарии и директивы препроцессора. Она используется в коде парсера как замена функции ``\texttt{lexer_peek_token}''.
Функция ``\texttt{parser_transfer_token}'' перемещает текущий токен лексера в нужный узел синтаксического дерева, список токенов которого передаётся ей по указателю.
Данная функция предназначена для замены функции ``\texttt{lexer_drop_token}'' с целью предотвращения потери токенов. В связи с этим токены извлекаются из лексера только тогда, когда есть место для их сохранения.

\begin{lstlisting}[language=c, caption={Вспомогательные функции парсера}, label={lst:parserutils}]
  Token parser_peek_token(Parser* p);
  void parser_transfer_token(Parser* p, Token** dest);
\end{lstlisting}

Парсер содержит функции формата ``\texttt{bool parser_parse_*}'', где ``\texttt{*}'' может быть заменено на конструкцию на языке C, такие как ``\texttt{struct}'', ``\texttt{type}'', ``\texttt{variable}'' или ``\texttt{declaration}''.
Эти функции анализируют текущую позицию в файле и пытаются распознать определенную конструкцию языка, и возвращают true, если конструкция действительно там присутствует. Если конструкция была успешно распознана, синтаксическое дерево этой конструкции записывается в указатель, который передается этой функции в качестве аргумента.

\subsection{Описание синтаксической структуры расширенного языка}

% todo[feedback]
% Это как раз стоит сказать до описания реализации. A реализацию
% конструкций уже можно давать без примеров кода, ссылаясь на
% соответствующие термины.

% <ОбобщеннаяСтруктура> ::= <Структура> `<' <СписокСпециализаций> `>'
% <СписокСпециализаций> ::= <ИмяТипа> `;' | <ИмяТипа> `;' <СписокСпециализаций>
% <РасширениеТипа> ::= <ИмяСтруктуры> `+' `<' <СписокСпециализаций> `>'
% <Специализация> ::= <ИмяСтруктуры> `<' <ИмяТипа> `>'
% <СпециализированнаяФункция> ::= <ТипВозврата> <ИмяФункции> `<' <СписокОбобщённыхПараметров> `>' `(' <СписокПараметров> `)'
% <ВызовПараметрическойФункции> ::= <ИмяФункции> `<' <СписокОбобщённыхПараметров> `>' `(' <СписокПараметров> `)'

В процедурно–параметрической парадигме имеются следующие конструкции, синтаксис которых необходимо добавить в разрабатываемый расширенный язык:
\begin{enumerate}
  \item \textbf{Обобщенная структура} --- это структура принимающая дополнительный параметр типа, и имеющая возможность принимать значения типа всех своих параметров. Основана на объединение (union) из процедурной парадигмы, и её также можно сравнить с абстрактным базовым классом из ООП.
  \item \textbf{Расширение обобщенной структуры} --- добавление ещё одного доступного типа для конкретной обобщённой структуры. У этой операции нет прямого эквивалента в других парадигмах.
  \item \textbf{Специализация обобщенной структуры} --- обобщенная структура, внутри которой лежит конкретный тип. В ООП эквивалентом будет дочерний класс.
  \item \textbf{Параметрическая функция} --- это особая функция, которая принимает на вход указатель к обобщённой структуре, и потом, на уровне языка выбирает правильную реализацию, основываясь на лежащим внутри неё типе. Определения параметрических функций, как и заголовки, не содержат тела функции и кода в нём. В ООП эквивалентом будет абстрактный виртуальный метод.
  \item \textbf{Реализация параметрической функции} --- в отличие от определения параметрической функции, её реализация принимает на вход в аргументах указатели не просто на обобщенную структура, а на её конкретную специализацию. В ООП эквивалентом будет реализация абстрактного метода.
  \item \textbf{Вызов параметрической функции} --- обычный вызов функции, только параметрические аргументы передаются в угловых скобках.
\end{enumerate}

\subsubsection{Обобщенная структура}

Обобщенная структура определяется путем объявления структуры и указания ее параметризации с помощью типов, которые передаются в угловых скобках. Для обеспечения более надёжной работы метакомпилятора, рекомендовано дать этой структуре имя.

Например, если у нас есть структура Figure, которая должна принимать значения типов Triangle, Rectangle и Circle, мы можем определить ее как указана в листинге \ref{lst:examplestruct}.
% or \ref{lst:fancystruct}

\begin{lstlisting}[language=c, caption={Пример обобщённой структуры}, label={lst:examplestruct}]
  struct Figure {} <
    struct Triangle;
    struct Rectangle;
    struct Circle;
  >;
\end{lstlisting}

Разрабатываемый метакомпилятор обязан превращать подобные обобщённые структуры в конструкции стандартного языка С.
Это происходит заменой списка параметров на объединение с сгенерированными именами полей, добавлением поля ``tag'', в котором будет храниться идентификатор типа, и заворачиванием основных полей структуры в подструктуру ``head'' (см. листинг \ref{lst:convertedstruct}).

\begin{lstlisting}[language=c, caption={Пример обобщённой структуры, сконвертированный в С}, label={lst:convertedstruct}]
  struct Figure {
    int tag;
    struct {} head;
    union {
      struct Triangle s00;
      struct Rectangle s01;
      struct Circle s02;
    } tail;
  };
\end{lstlisting}

\subsubsection{Расширение обобщенной структуры}

В обобщённую структуру можно добавлять типы после её определения.
Этот функционал необходим для расширения уже существующих типов из внешних модулей.
В языке программирования C компиляция может происходить параллельно для разных единиц трансляции (translation unit), и компилятор никак не может узнать о существование других файлов, которые могут использовать данный тип, до этапа компоновки.
Поэтому расширение типов должно происходить так, чтобы итоговый результат не зависел от порядка компиляции модулей.

Синтаксис для расширения довольно простой. Необходимо написать имя обобщённой структуры, и ``прибавить'' к ней список новых параметров (см. листинг \ref{lst:exampleexpand}).

\begin{lstlisting}[language=c, caption={Пример расширения обобщенной структуры}, label={lst:exampleexpand}]
  struct Figure + <struct Box;>;
\end{lstlisting}

\subsubsection{Специализация обобщенной структуры}

Поскольку типы обобщённых структур не полностью определены, создание переменной такого типа невозможно и необходимо использовать специальный синтаксис для определения конкретной специализации обобщённой структуры (см. листинг \ref{lst:examplevar}).
Метакомпилятор заменит такой тип на модифицированную версию обобщённой структуры, в которой поле ``tail'' является конкретной структурой (см. листинг \ref{lst:examplevartype}).
Также имеется особый формат инициализаторов для таких переменных, контент которых копируется в специальный инициализатор без изменений.

\begin{lstlisting}[language=c, caption={Пример специализации, для определения переменной}, label={lst:examplevar}]
  Figure<Box> my_box;
  Figure<Circle> my_circle = {}<{.r = 1, .x = 10, .y = 5}>;
\end{lstlisting}

\begin{lstlisting}[language=c, caption={Пример специализации, сконвертированный в С}, label={lst:examplevartype}]
  struct Figure_Box {
    int tag;
    struct {} head;
    Box tail;
  };
\end{lstlisting}

Также при инициализации переменной такого типа, необходимо присвоить правильное значение полю tag.
Разрабатываемый метакомпилятор достигает такого результата используя инициализаторы с поимённой инициализацией полей, которые были введены в стандарте C99 (см. листинг \ref{lst:examplevarinit}).

\begin{lstlisting}[language=c, caption={Пример инициализации специализации}, label={lst:examplevarinit}]
  struct Figure_Box my_box = {.tag = Figure_Box_tag_value};
  struct Figure_Circle my_circle = {.tag = Figure_Box_tag_value, .tail = {.r = 1, .x = 10, .y = 5}};
\end{lstlisting}

\subsubsection{Параметрическая функция}

Параметрическая функция может быть определена двумя способами: заголовок или метод с пустым телом, то есть ``\texttt{= 0}'' (см. листинг \ref{lst:examplefunc}).
Заголовок обычно встречается в заголовочных файлах и нужен чтобы функция выла видна из других единиц компиляции.
А метод с пустым телом становится полноценной имплементаций, которая достаёт указатель на правильную функцию из глобальной таблицы (см. листинг \ref{lst:convertedfunc}).

\begin{lstlisting}[language=c, caption={Пример параметрической функции}, label={lst:examplefunc}]
  void Draw<Figure* f>();

  bool Intersect<Figure* f1, Figure* f2>() = 0;
\end{lstlisting}

\begin{lstlisting}[language=c, caption={Пример параметрической функции, сконвертированный в С}, label={lst:convertedfunc}]
  void Draw(Figure* f);

  bool Intersect(Figure* f1, Figure* f2) {
    return Intersect_table[f1->tag + f2->tag * Figure_tag_count](f1, f2);
  }
\end{lstlisting}

\subsubsection{Реализация параметрической функции}

Реализации параметрической функции определяются также как и она сама, только у них есть тело с кодом, и в списке параметров все обобщенные структуры специализированны (см. листинг \ref{lst:examplefuncimpl}).

\begin{lstlisting}[language=c, caption={Пример реализации параметрической функции}, label={lst:examplefuncimpl}]
  void Draw<Figure<Rectangle>* r>() {
    printf("Rectangle: x = %d, y = %d", r->!x, r->!y);
  }
\end{lstlisting}

Для реализаций праметрических функций, метакомпилятор анализирует их тело на предмет специальных операторов ``\texttt{->!}'', которые используются для доступа к полям специализации обобщенной структуры.
Доступ к этим полям производиться через поле ``tail'' конвертированной обобщённой структуры (см. листинг \ref{lst:convertedfuncimpl}).

\begin{lstlisting}[language=c, caption={Пример реализации параметрической функции, сконвертированный в С}, label={lst:convertedfuncimpl}]
  void Draw_Figure_Rectangle(Figure_Rectangle* r) {
    printf("Rectangle: x = %d, y = %d", r->tail.x, r->tail.y);
  }
\end{lstlisting}

\subsubsection{Вызов параметрической функции}

В параметрическую функцию часть параметров передаётся в угловых скобках (см. листинг \ref{lst:examplecall}).
Для вызова параметрической функции не нужно производить особых операций.
Нужно просто переместить параметрические аргументы в обычные, то есть из угловых в круглые скобки (см. листинг \ref{lst:convertedcall}).
Это можно сделать даже из кода на обычном С, без использования метакомпилятора, если для параметрической функции в нём определён правильный заголовок.

\begin{lstlisting}[language=c, caption={Пример вызова параметрической функции}, label={lst:examplecall}]
  Draw<&my_box>();
\end{lstlisting}

\begin{lstlisting}[language=c, caption={Пример вызова параметрической функции, сконвертированный в С}, label={lst:convertedcall}]
  Draw(&my_box);
\end{lstlisting}

\subsection*{Выводы по главе}
\addcontentsline{toc}{subsection}{Выводы по главе}
В данной главе была описана архитектура компилятора, который преобразует исходный код нашего языка программирования в машинный код. Были описаны основные структуры данных, используемые компилятором, такие как лексер, парсер и хеш-таблицы.
Затем были рассмотрены различные конструкции языка, таких как обобщенные структуры и функции, расширения типов и вызовы параметрических функций.
В целом, было получено хорошее представление о том, как язык программирования будет выглядеть и как он будет работать.
