\section{Объекты испытаний}
\subsection{Наименование программы}
<<\CRTname>>

\subsection{Область применения программы}
Программа используется в повседневной жизни, когда требуется заказать продукцию из нескольких интернет магазинов сразу.

\section{Цель испытаний}
Целью проведения описанных далее испытаний является проверка корректности работы программы,
а также её соответствия требованиям, изложенным в документе <<Техническое задание>>.

\section{Требования к программе}
\input{tz-parts/requirements} % todo?
\section{Требования к программной документации}
\input{tz-parts/docs} % todo?

\section{Средства и порядок испытаний}
\subsection{Технические средства, используемые во время испытаний}
\begin{enumerate}
  \item 64-разрядный (x64) 1 ядерный процессор;
  \item 2 ГБ оперативной памяти (ОЗУ);
  \item 1 ГБ свободного места на внутреннем накопителе для программы и ее зависимостей;
\end{enumerate}
\subsection{Программные средства, используемые во время испытаний}
\begin{enumerate}
  \item ОС Ubuntu 18.04.6 или аналогичная ей оперативная система;
  \item компилятор GCC языка программирования С версии 12.2.0 или больше;
  \item сборочная система GNU Make и подобные вспомогательные программы, необходимы для компиляции кода на языке программирования C;
  \item установленная программа \cmd{curl}, которая также необходима для компиляции программы.
\end{enumerate}

\subsection{Порядок проведения испытаний}
Испытания должны проводиться в следующем порядке:
\begin{enumerate}
  \item Выполнить начальную загрузку операционной системы.
  \item Скачать на компьютер архив c исходным кодом и распаковать его.
    Альтернативно допускается клонирование публичного Git репозитория по ссылке \url{https://github.com/Cortan122/ppp-compiler/}.
  \item Установить всё необходимое программное обеспечение.
    В операционной системе Ubuntu данный процесс производиться по средствам командной строки терминала.
    Для установки всего нужного программного обеспечения необходимо выполнить команду \cmd{sudo apt install build-essential curl}.
    Она требует административного доступа к данному устройству.
  \item Скомпилировать метакомпилятор используя команду \cmd{make all}.
  \item Запустить автоматизированные тесты командой \cmd{make run\_tests}, и промерить правильно ли метакомпилятор находит синтаксические ошибки в предоставленных ему тестовых файлах.
  \item Провести необходимые испытания, описанные ниже в разделе <<Методы испытаний>>.
\end{enumerate}

\section{Методы испытаний}
Испытания представляют собой процесс установления соответствия программы и программной документации заданным требованиям.

\subsection{Подготовка к проведению испытаний}
Испытания представляют собой процесс проверки документации и программы на соответствие установленным в техническом задании требованиям.
В комплект поставки программы входит архив с технической документацией, готовой реализацией программного продукта и презентацией проекта.
Перед проведением испытаний необходимо распаковать архив с исходным кодом, открыть окно терминала с командной оболочкой Bash, и скомпилировать программу, используя команду \cmd{make all}.

\subsection{Испытание выполнения требований к программной документации}
Состав программной документации проверяется визуально,
проверяется наличие всех подписей и наличие программной документации в системе LMS.
Также визуально проверяется соответствие документации требованиям ГОСТ. Все документы удовлетворяют представленным требованиям.

\subsection{Проверка требований к функциональным характеристикам}
\subsubsection{Требования к организации входных данных}
Для проверки правильности требований ко входным данным, а именно что разработанный метакомпилятор принимает на вход исходный код на языке программирования C, необходимо сначала написать небольшую программу на С.
Пример такой программы приведён в листинге \ref{lst:helloworldc99}.

\begin{lstlisting}[language=c, caption={Пример простейшей программы на стандартном C}, label={lst:helloworldc99}]
  #include <stdio.h>

  int main(void) {
    printf("Hello world\n");
    return 0;
  }
\end{lstlisting}

Далее необходимо проверить правильность написания этой программы используя компилятор GCC.
Это можно сделать используя команду \cmd{gcc -Wall -o/dev/null программа.c}.
Если компилятор GCC завершился успешно, и не указал на наличие синтаксических ошибок,
нужно прогнать её через метакомпилятор используя команду \cmd{./main программа.c}.
В результате метакомпилятор должен успешно завершиться и вывести текст программы с небольшими незначительными изменениями
\CRTfigref{basicinputtest}{Проверка входных данных}.

\subsubsection{Требования к организации выходных данных}
Для проверки того, что метакомпилятор производит на выходе программный код на стандартном языке C, можно использовать компилятор GCC.
В качестве программы можно использовать туже самую, что и в предыдущем пункте (см. листинг \ref{lst:helloworldc99}), только сохранить результат метакомпилятора в отдельный файл \cmd{программа.out.c}.
Также необходимо проверить что программа работает как надо \CRTfigref{basicoutputtest}{Проверка выходных данных}.

Кроме того, необходимо проверить наличие возможности автоматической передачи кода на следующие этапы компиляции.
Для этого стоит использовать исполняемый файл \cmd{wrapper}.
Он принимает командные аргументы в том же формате что и любой другой компилятор языка программирования C.
Например, в него можно передать аргумент \cmd{-o./my\_program}, чтобы изменить имя создаваемого исполняемого файла \CRTfigref{basicwrappertest}{Проверка передачи кода на следующий этап}.

\subsubsection{Требования к надежности}
Чтобы проверить что в программе отсутствуют утечки памяти и ошибки сегментации, необходимо скомпилировать её заново с использованием санитизации адресов, то есть с флагом \cmd{-fsanitize=address}.
В используемой системе сборки, это можно сделать командой \cmd{USE_ASAN=True make -B all run\_tests}, которая также произведёт повторный запуск автоматических тестов.
В дальнейшем, можно будет повторить все испытания с такой конфигурацией программы.
В случае нахождения ошибки, Address Sanitizer~\cite{llvmAddressSanitizerx2014} выведет такое сообщение \CRTfigref{memoryleaks}{Сообщение об утечке памяти}.

Также необходимо проверить устойчивость метакомпилятора к синтаксическим ошибкам в исходном коде.
Для этого нужно модифицировать тестовую программу, которая была написана для одного из предыдущих тестов, так, чтобы в ней была синтаксическая ошибка (см. листинг \ref{lst:syntaxerror}).

\begin{lstlisting}[language=c, caption={Пример программы с синтаксической ошибкой}, label={lst:syntaxerror}]
  #include <stdio.h>

  typedef {int f;} struct Name;

  int main(void) {
    printf("Hello world\n");
    return 0;
  }
\end{lstlisting}

Наличие синтаксической ошибки можно проверить через компилятор GCC используя команду \cmd{gcc программа.c}.
После чего можно будет запустить сам метакомпилятор командой \cmd{./main программа.c},
и проверить наличие ошибки в стандартном выводе \CRTfigref{wrongprogram}{Проверка ловли синтаксических ошибкок}.

\subsubsection{Требования к интерфейсу}
Интерфейс реализован через два исполняемых файла, запускаемых через командную строку:
\begin{enumerate}
  \item Файл \cmd{./main} предоставят возможность конвертировать уже препроцессированный код на расширенном языке программирования C в стандартный код.
  Имя входного файла передаётся первым аргументом, и допускается использование исходного непрепроцессированного кода, хотя этот функционал не рекомендован к использованию (см. Рис. \ref{fig:basicinputtest}).
  Также предоставляется опция перенаправления выхода в отдельный файл, имя которого передаётся вторым аргументом в команду.
  В таком случае в поток стандартного выхода выводиться список определений, который метакомпилятор нашёл в данной ему программе \CRTfigref{mainoutputthing}{Перенапровления выхода для файла \cmd{./main}}. Файл \cmd{./main} не обрабатывает командные опции.

  \item Файл \cmd{./wrapper} предоставляет командный интерфейс, схожий с любым другим компилятором языка C, разработанным под Unix подобную систему.
  Он принимает на вход, в виде командного аргумента, имя файла с исходном кодом на расширенном языке программирования C, запускает на этом коде препроцессор, метакомпилятор и компилятор, и организовывает межпроцессорные потоки для передачи данных.
  Также все командные опции, то есть аргументы начинающиеся с символа \cmd{-}, передаются запущенному компилятору.
  Таким образом можно, например, указать имя создаваемого исполняемого файла (см. Рис. \ref{fig:basicwrappertest}).
\end{enumerate}

Оба исполняемых файла выводят наеденные в процессе метакомпиляции синтаксические ошибки в поток стандартного вывода ошибок (stderr).
Они отлавливают как и ошибки, связанные с специфическими конструкциями процедурно-параметрической парадигмы программирования
\CRTfigref{cascadingerror}{Пример ошибки в определении параметрического типа},
так и некоторые ошибки синтаксиса самого языка C, такие как, например, неправильные определения типов (см. Рис. \ref{fig:basicwrappertest}).

\subsection{Проверка требований к грамматике языка}
\subsubsection{Определение параметрического обобщения}
Чтобы проверить правильность реализации определения обобщённой структуры, необходимо написать программу, соответствующую данной грамматике, и скомпилировать её с помощью метакомпилятора.
Пример программы, соответствующей грамматике определения обобщённой структуры, можно найти в листинге \ref{lst:fancystructwithmain}.

\begin{lstlisting}[language=c, caption={Пример программы с обобщённой структурой}, label={lst:fancystructwithmain}]
  #include <stdio.h>

  typedef struct Type1 {int  i;} Type1;
  typedef struct Type2 {char c;} Type2;
  typedef struct Name {}<Type1; Type2;> Name;

  int main(void) {
    printf("Hello world\n");
    return 0;
  }
\end{lstlisting}

В этом примере определена обобщенная структура Name и её специализации Type1 и Type2, которые содержат поля разных типов.
В функции main они пока не используются, так как необходимо проверить только возможность их определения.
Теперь нужно запустить метакомпилятор и проверить сохранилась ли работоспособность программы
\CRTfigref{fancystructwithmain-old}{Пример компиляции обобщённой структуры}.

Кроме проведения такой автоматической проверки, можно ознакомиться с промежуточным кодом, который выдает метакомпилятор, и убедиться в его корректности.
Для этого стоит использовать команду \cmd{./main программа.c | bat -Pl c}, а не \cmd{./wrapper программа.c}.
Программа \cmd{bat} в данном случае используется только для синтаксической подсветки и улучшения читаемости кода, и поэтому её можно упустить \CRTfigref{fancystructwithmain}{Сконвертированный код обобщённой структуры}.

\subsubsection{Использование конкретной специализации, в качестве типа переменной}
Так как для тестирования данной синтаксической конструкции также необходимо определить обобщённую структуру,
можно не переписывать тестовую программу с нуля, а вместо этого просто модифицировать существующий код,
который был написан в предыдущей секции (см. листинг \ref{lst:fancystructwithmain}).
В эту тестовую программу необходимо добавить определение переменной,
типом которой является конкретная специализация уже определённой обобщённой структуры.
Для этого требуется изменить содержимое функции main, в соответствие с листингом \ref{lst:fancystructonlymain}.

\begin{lstlisting}[language=c, caption={Изменённая функция main}, label={lst:fancystructonlymain}]
  int main(void) {
    Name<Type1> var;
    var!i = 1;
    printf("value of i = %d\n", var!i);
    return 0;
  }
\end{lstlisting}

Приведённая программа определяет переменную \cmd{var} типа \cmd{Name<Type1>},
присваивает значение 1 полю \cmd{i}, и выводит эту информацию в поток стандартного вывода.
В данной программе также используется оператор \cmd{!} для доступа к полям обобщённой структуры.
Для уменьшение количества кода, который надо проверять вручную, можно использовать команду \cmd{grep},
чтобы показать только те строчки кода, на которых упоминается созданная переменная
\CRTfigref{basicvarexample}{Пример компиляции переменной}.

\subsubsection{Определение специализированной функции}
Также как и с определением специализированной переменной, для определения функции нужно иметь готовое определения обобщённого типа,
и поэтому в данном случае также стоит расширить предыдущею программу.
Необходимо добавить в тестовую программу код, данный в листинге \ref{lst:fancyfuncnomain}, сразу после определения обобщённой структуры.

\begin{lstlisting}[language=c, caption={Определение специализированной функции}, label={lst:fancyfuncnomain}]
  void display<Name* a>() = 0;

  void display<Name<Type1>* a>() {
    printf("Name<Type1> = %d\n", a->!i);
  }
\end{lstlisting}

Полученная тестовая программа представляет собой определение двух функций: \cmd{display<Name* a>} и \cmd{display<Name<Type1>* a>}.
Функция \cmd{display<Name* a>} объявлена как параметрическая функция (с помощью \cmd{= 0}), что означает, что её реализации должны быть предоставлены для каждого специализированного типа, с которым планируется её использовать.
В данном случае она не содержит никакого кода.

Функция \cmd{display<Name<Type1>* a>} представляет собой конкретную реализацию для случая, когда \cmd{Name} является обобщенной структурой с параметром типа \cmd{Type1}.
Она выводит значение переменной \cmd{!i} (так как внутри этой функции известно, что в структуре \cmd{Type1} есть поле \cmd{i}) с помощью функции \cmd{printf} в поток стандартного вывода.

В результате метакомпиляции данной программы получается довольно большой объём кода, который также можно отфильтровать используя команду \cmd{grep}
\CRTfigref{ohgodwhyisitsolong}{Строки кода, которые были изменены в последствии добавления функции}.
Такой код позволяет реализовать динамическое связывание функций во время выполнения программы, обеспечивая гибкость и возможность использования различных реализаций в зависимости от типа объектов.

\subsubsection{Вызов специализированной функции}
Далее необходимо проверить возможность вызова функции \cmd{display} с объектом типа \cmd{Name} и проверка правильности вывода результата. Можно создать несколько объектов разных типов \cmd{Name} и убедиться, что функция \cmd{display} вызывает соответствующую реализацию в зависимости от типа объекта и правильно выводит результат.
Для этого надо поменять одну строку кода в функции \cmd{main} (см. листинг \ref{lst:fancyfunccall}).

\begin{lstlisting}[language=c, caption={Вызов специализированной функции}, label={lst:fancyfunccall}]
  int main(void) {
    Name<Type1> var;
    var!i = 1;
    display<&var>();
    return 0;
  }
\end{lstlisting}

В получившейся программе вызывается функция display, определённая в листинге \ref{lst:fancyfuncnomain}, с указателем на переменную \cmd{var} в качестве аргумента.
В данном случае, функция display будет вызывать реализацию \cmd{__ppp__display_Name_Type1} для типа \cmd{Name<Type1>}, которая выводит на экран сообщение \cmd{"Name<Type1> = 1"}.
Также можно посмотреть на изменение в коде, которые были проведены для корректного вызова данной функции
\CRTfigref{callingthefuckingdisplayfunction}{Строки кода, которые были изменены для вызова функции}.

\subsubsection{Расширение обобщённой структуры}
Также метакомпилятор имеет возможность расширять уже определённые обобщённые структуры, добавляя в них новые типы специализаций.
Этот функционал предназначен для работы с несколькими единицами компиляции, но он также работает и в одном файле.
Чтобы его проверить мы можем написать программу, которая будет выводить внутренние значения обобщённой структуры \cmd{Name},
которые метакомпилятор использует под капотом (см. листинг \ref{lst:extendstructallfancylike}).

\begin{lstlisting}[language=c, caption={Расширение структуры и вывод внутренних значений}, label={lst:extendstructallfancylike}]
  typedef struct Type3 {float f;} Type3;
  struct Name + <struct Type3;>;

  int main(void) {
    printf("tag_value Type1 = %d\n", __ppp__tag_value_Name_Type1);
    printf("tag_value Type2 = %d\n", __ppp__tag_value_Name_Type2);
    printf("tag_value Type3 = %d\n", __ppp__tag_value_Name_Type3);
    printf("tag_counter Name = %d\n", __ppp__tag_counter_Name);
    return 0;
  }
\end{lstlisting}
В данной программе происходит определение структуры \cmd{Type3} с полем типа \cmd{float}.
Затем происходит расширение структуры \cmd{Name} путем добавления \cmd{Type3} к списку специализаций.
В функции \cmd{main} происходит вывод на экран значений различных служебных переменных, связанных с обобщенной структурой \cmd{Name}.
Этот код позволяет проверить значения тегов и количество типов, что полезно для контроля корректности определения и использования обобщенной структуры \cmd{Name}.

Метакомпилятор устроен так, что получаемый код при добавление специализации в обобщённую структуру с помощью расширения, почти не отличается от случая, когда специализация входила в структуру с самого начала.
После запуска программы, значения тегов специализаций должны быть от 0 до 2 в неопределённом порядке
\CRTfigref{justthetagvalues}{Значения служебных переменных}.

\subsection{Проверка требований к возможностям метакомпилятора}
\subsubsection{Использование нескольких единиц компиляции}
Для проверки возможности использования нескольких единиц компиляции в метакомпиляторе необходимо выполнить следующие шаги:
\begin{enumerate}
  \item Создать несколько исходных файлов, содержащих разные части программы.
  Например можно в одной файле определить обобщению структуру, а в другом параметрическую функцию.
  \item Запустите метакомпилятор для каждого из исходных файлов, указав все необходимые опции для компиляции.
  Например можно использовать команду \cmd{./wrapper -c -oфайл1.o файл1.c}.
  \item Проверить, что метакомпилятор успешно скомпилировал все единицы компиляции и объединить их используя обычный компоновщик GCC.
  Для этого потребуется команда \cmd{gcc файл1.o файл2.o}.
  \item Выполнить необходимые проверки и тесты для убедительности, что все части программы, распределенные по разным единицам компиляции, работают корректно вместе.
\end{enumerate}

Листинги \ref{lst:splitfileone} и \ref{lst:splitfiletwo} иллюстрируют пример минимальной разделенной программы, где разные единицы компиляции могут работать вместе.

\noindent
\begin{minipage}[t]{.5\textwidth}
\begin{lstlisting}[language=c, caption={Пример основного файла разделённой программы}, xleftmargin=0mm, frame=L, label={lst:splitfileone}]
#include <stdio.h>

typedef struct Type1 {int  i;} Type1;
typedef struct Name {}<Type1;> Name;

void display<Name* n>();

int main(void) {
  Name<Type1> var = {}<{.i = 2}>;
  display<&var>();
  return 0;
}
\end{lstlisting}
\end{minipage}%
\begin{minipage}[t]{.5\textwidth}
\begin{lstlisting}[language=c, caption={Пример вторичного файла разделённой программы}, xleftmargin=0mm, frame=LR, label={lst:splitfiletwo}]
#include <stdio.h>

typedef struct Type1 {int  i;} Type1;
typedef struct Name {}<Type1;> Name;

void display<Name* n>() = 0;

void display<Name<Type1>* a>() {
  Name* p = a;
  printf("Name.tag = %d\n", p->tag);
  printf("Name<Type1> = %d\n", a->!i);
}
\end{lstlisting}
\end{minipage}

В данной программе, код основного файла создает экземпляр обобщенной структуры \cmd{Name} с параметром \cmd{Type1}, инициализирует поле \cmd{i} значением 2, а затем вызывает параметрическую функцию \cmd{display}, которая была определена в дополнительном файле, для вывода значения поля \cmd{i} в поток стандартного вывода \CRTfigref{multifiledemo}{Компиляция разделённой программы}.

\subsubsection{Правильная нумерация строк в ошибках}
Для проверки того, что метакомпилятор сохраняет правильную нумерацию строк при выводе сообщений об ошибках, необходимо
написать программу на расширенном языке C, для которого используется метакомпилятор, и добавить в неё некорректный код или синтаксические ошибки (см. листинг \ref{lst:mainerrornegativeone}).
Если номера строк в сообщениях об ошибках соответствуют правильной нумерации в исходном коде, это указывает на то, что метакомпилятор сохраняет правильную нумерацию строк для вывода сообщений об ошибках.

\begin{lstlisting}[language=c, caption={Пример функции main с ошибкой}, label={lst:mainerrornegativeone}]
  int main(void) {
    int array[-1];
    return 0;
  }
\end{lstlisting}

В результате выполнения команды \cmd{./wrapper программа.c}, в терминале выводится сообщение об ошибке.
Ошибка указывает, что в функции \cmd{main} на строке 14 обнаружена проблема: размер массива \cmd{array} отрицательный.
Но с помощью команды \cmd{grep} можно заметить что в получившимся промежуточном коде данная ошибка располагается на строке 28.
Также показано что в исходном файле \cmd{программа.c} ошибка находилась именно на 14ой строке.
\CRTfigref{linenumbers}{Сравнение номеров строк ошибок}.

% \subsubsection{Требования ко всему остальному} % ну да...
% TODO
% Предоставлять поддержку базовых конструкций языка программирования C, таких как переменные, функции, условные операторы и циклы, пропуская код без изменений;
% Предоставлять возможность объявления пользовательских типов данных и структур данных;
% Предоставлять возможность обработки исходного кода на языке C, после того как он прошёл этап препроцессора;
% Запускать компилятор и препроцессор языка C и организовывать межпроцессную коммуникацию между ними;
% Хранить таблицу имён переопределённых типов, обобщённых структур, специализированных переменных и параметрических функций.
