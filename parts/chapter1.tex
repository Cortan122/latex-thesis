В данной главе будут рассмотрены существующие аналоги, их преимущества и недостатки.

\subsection{Анализ существующих решений}

Эволюционное расширение программ обычно осуществляется через Динамический полиморфизм.
Он позволяет обрабатывать ветви программы во время выполнения без явной проверки альтернативных вариантов.
В отличие от статического полиморфизма, где альтернативные вычисления выявляются во время компиляции. Изначально решения, связанные с динамическим полиморфизмом, были разработаны для объектно-ориентированных (ООП) языков программирования, где применяется утиная типизация. Это позволяет объектам с одинаковой сигнатурой метода обрабатывать обращения к нему, независимо от связи между объектами. Утиная типизация была изначально реализована Smalltalk~\cite{shafer2012practical}, а потом в скриптовых языках программирования, таких как Python~\cite{hunt2019advanced} и JavaScript~\cite{diaz2008pro}.

В ООП языках со статической типизацией данная проблема была решена совместным использованием механизмов наследования и виртуализации.
Наследование обеспечивает идентичность интерфейсов родительского и дочернего классов, а виртуализация позволяет подменять реализацию методов в дочерних классах. Этот подход был реализован в языках C++~\cite{bookcplusplus}, Java~\cite{bookjava}, C\#~\cite{albahari2010c} и многих других ООП языках программирования.

Процедурно-параметрическая парадигма программирования --- альтернатива, предложенная для эволюционно расширяемого множественного полиморфизма. Она использует параметрический механизм для формирования отношений между данными и процедурами, позволяя расширять данные и функции без отказа от статической типизации. Этот подход был протестирован на языке программирования O2M, расширяющем Оберон-2, и может быть легко интегрирован в существующие языки программирования~\cite{легалов2003процедурный}. Процедурно-параметрический полиморфизм обеспечивает более гибкое эволюционное расширение программ по сравнению с другими методами поддержки динамического полиморфизма.

В итоге получается следующий краткий существующих список аналогов:
\begin{enumerate}
  \item Утиная типизация в скриптовых языках программирования;
  \item Наследование и виртуализация методов в объектно-ориентированных языках программирования;
  \item Механизм типажей и интерфейсов в языках Go и Rust;
  \item Язык O2M основанный на Оберон-2.
\end{enumerate}

% todo[feedback]
% На самом деле к этому списку можно добавить полиморфизм, который
% реализован в языка Go и Rust. В Go это интерфейсы и связанные с
% ними функции. B Rust тоже аналогичный механизм на основе типажей.
% Обеспечивается поддержка полиморфизма, аналогичного объектно-
% ориентированному.

\subsection{Доступные методы расширения компилятора}

Существует четыре основных подхода к реализации нового расширения языка в контексте C: преобразование исходного кода, модификация существующего компилятора, написание своего компилятора с нуля, а также компиляция в промежуточное представление LLVM~\cite{llvm} используя экосистему Сlang, или другого продвинутого компилятора.

Подход преобразования исходного кода предполагает написание препроцессора, который читает исходный код, применяет нужные преобразования и затем выводит преобразованный исходный код.
Этот подход имеет преимущество в том, что он относительно прост и прямолинеен, поскольку не требует полной реализации языка или знания экосистемы (как в Clang), которая гораздо шире, чем экосистема языка C.
Также он может облегчить понимание и отладку преобразованного кода.
Однако недостатком является то, что ошибки из исходного кода могут распространяться на полученный код, что приводит к неверным номерам строк, сообщаемым компилятором.
Подобные сложности затрудняют процесс разработки со стороны конечного пользователя расширенного компилятора, однако можно улучшить эту ситуацию, используя соответствующие инструменты для отладки и тестирования кода.
Например, в языке С существует директива препроцессора `\#line'.

% todo[feedback] at "обширных знаний о компиляторе"
% Любой из подходов требует идентичных знаний. Но этот подход менее затратный, так как не требует полной реализации языка и (или) знания экосистемы (как в Clang), которая гораздо шире, чем экосистема языка Си.

% Здесь наверное стоит говорить о написании своего компилятора, так
% как использование других больше связано с их общей экосистемой. B
% ССС те жe возможности, что и в Clang.
% Также можно отметить наличие более простых компиляторов типа TinyСС,
% которые затормозились в дальнейшем развитии.

Подход компиляции в LLVM предполагает модификацию фронтенда компилятора для распознавания новых конструкций языка и вывода промежуточного представления вместо машинного кода.
Это имеет преимущество в том, что позволяет использовать более сложные оптимизации и, возможно, добиться более высокой производительности, так как промежуточное представление может быть оптимизирован с помощью набора инструментов LLVM.
Однако этот подход может быть более сложным и требовать большего знания о используемом наборе инструментов, а полученное промежуточное представление может быть более сложным для чтения и отладки, чем исходный код.

Подход модификации существующего компилятора заключается в том, чтобы внести изменения в исходный код существующего компилятора для добавления поддержки новых языковых конструкций или функциональности.
Этот подход может иметь преимущества, такие как использование существующей инфраструктуры и опыта в разработке компиляторов, а также возможность получения высокой производительности.
Однако, существующие компиляторы C, такие как GCC и Clang, очень большие, что делает их сложными для понимания и модификации. Кроме того, изменения, внесенные в основной код компилятора, могут привести к несовместимости с существующими проектами, использующими этот компилятор.

Проблему масштабности существующих компиляторов можно конечно решить написанием нового простейшего компилятора с нуля.
Такое решение чревато большими затратами на изучение и написание некоторых частей компилятора, которые не являются ключевыми целями данного проекта, и может занять значительное количество времени и ресурсов.
Написание нового компилятора с нуля может привести к проблемам совместимости, неэффективному использованию ресурсов и потере функциональности, которая уже реализована в существующих компиляторах.
Вместо этого, стоит рассмотреть модификацию и адаптацию существующих простых компиляторов, как например TinyСС, разработка которых затормозилась в дальнейшем развитии.

\subsection{Выбор метода расширения компилятора}

% To simplify the task of implementing a C compiler with new language features, I opted to use the LibTooling and LibASTMatchers libraries from the Clang ecosystem.
% These libraries provide a range of high-level tools and abstractions that allow for more efficient development of custom compiler extensions.
% By using these libraries, I can focus on implementing the new language features I want to add, rather than worrying about the intricacies of building a C compiler from the ground up.

% However, as the development process progressed, it became apparent that using LibTooling and LibASTMatchers alone would not be sufficient for the scope of the language extensions we wanted to add.
% We realized that we would need to modify the entire Clang compiler in order to fully support our desired language features.
% However, this presented a significant challenge, as the Clang compiler is a very large and complex system.
% We ultimately decided to pivot our approach and explore alternative methods for implementing our language extensions, rather than attempting to modify the entire Clang compiler.

В начале выл сделан выбор использовать LibTooling и LibASTMatchers для реализации расширения на языке C++.
LibTooling предоставляет API для написания инструментов, которые могут обрабатывать и изменять исходный код на основе абстрактного синтаксического дерева (AST)~\cite{LibTooling}. LibASTMatchers --- это библиотека для написания запросов на основе AST, которые позволяют находить конкретные узлы синтаксического дерева, соответствующие определенным критериям.
Использование этих библиотек позволяет создавать инструменты, которые могут помочь программистам обнаруживать и устранять ошибки, повышать качество кода, автоматизировать процессы рефакторинга и тестирования, а также улучшать производительность приложений.

Однако, после проведения более детального исследования, стало понятно, что для реализации нужного расширения необходимо модифицировать весь компилятор Clang. Это вызвало определенные сложности и затруднения, так как Clang является очень большим и сложным проектом. В результате, было принято решение отказаться от идеи использовать Clang.

Также была рассмотрена опция модификации исходного кода маленького компилятора TCC (Tiny C Compiler)~\cite{bellard2003tcc}, но пришлось отказаться от такого решения, в связи с и ограниченными возможностями данного компилятора.
Для полноценной реализации процедурно-параметрической парадигмы необходимы такие нестандартные возможности языка программирования С как `attribute constructor' и `attribute week', которые доступны  только в полноценных компиляторах GCC и Clang.
Более того, модификация существующего компилятора оказалось довольно сложной задачей, не смотря на относительно небольшой размер его кодовой базы.

Из-за сложностей и ограничений, связанных с использованием более сложных подходов, было принято окончательное решение о разработке source-to-source компилятора (далее метакомпилятор) для реализации языкового расширения.
Этот подход был выбран в связи с его относительной простотой реализации и низким порогом вхождения для разработчиков.
Такой подход позволит обеспечить поддержку языковых расширений на широком диапазоне платформ и ускорить их внедрение в существующие проекты на языке C.

В контексте данного подхода можно упомянуть библиотеку Qt, где также используется синтаксически управляемый препроцессинг. Qt включает в себя метакомпилятор, который запускается перед компиляцией программ на С++ и генерирует дополнительные конструкции и их описание на С++ в отдельных файлах~\cite{qtUsingMetaObject}.

Для того, чтобы не заниматься реализацией препроцессора заново, было принято решение использовать уже препроцессированный код на входе нашего компилятора. Это было возможно благодаря тому, что компилятор GCC имеет опцию `-E', которая выполняет только этап препроцессирования и выводит препроцессированный код на стандартный вывод~\cite{wall2004basicgcc}. Эта опция использовалась для препроцессирования исходного кода перед его передачей разработанному компилятору. Затем полученный препроцессированный код передавался в качестве входных данных для компилятора GCC, который выполнял последующие этапы компиляции и генерации исполняемого файла. Таким образом, была использована мощь GCC в качестве основы полученного компилятора. Также это дало возможность избежать необходимости реализовывать этап препроцессирования заново.

% todo[feedback]
% В данном контексте можно сослаться на Qt, в котором тоже
% используется синтаксически управляемый препроцессинг. Имеется
% метакомпилятор, запускаемый перед компиляцией программ на С++ и
% создающий при компиляции дополнительных конструкций их описание
% на С++ в отдельных файлах.

\subsection*{Выводы по главе}
\addcontentsline{toc}{subsection}{Выводы по главе}
В данной главе были рассмотрены различные подходы к решению задачи создания процедурно-параметрического языка программирования на основе языка C. Были рассмотрены три основных подхода: использование библиотеки LibTooling и LibASTMatchers, модификация существующего компилятора и написание метакомпилятора, который преобразовывает исходный код. После анализа этих подходов было решено использовать последний --- написание метакомпилятора. Данный подход позволяет избежать сложностей, связанных с модификацией крупных компиляторов, и не требует глубокого понимания внутреннего устройства компиляторов. Более того, использование уже препроцессированного кода C позволяет избежать реализации препроцессора и использовать готовые средства компиляции, такие как GCC.
